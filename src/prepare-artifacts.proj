<Project Sdk="Microsoft.Build.NoTargets">

  <PropertyGroup>
    <TargetFramework>$(NetCurrent)</TargetFramework>
    <!-- Set IsStableBuild to mimic https://github.com/dotnet/arcade/blob/694d59f090b743f894779d04a7ffe11cbaf352e7/src/Microsoft.DotNet.Arcade.Sdk/tools/Publish.proj#L30-L31 -->
    <IsStableBuild>false</IsStableBuild>
    <IsStableBuild Condition="'$(DotNetFinalVersionKind)' == 'release'">true</IsStableBuild>
    <!-- Don't stabilize the package version in order to retrieve the VersionSuffix. -->
    <IsShipping>false</IsShipping>
    <SuppressFinalPackageVersion>true</SuppressFinalPackageVersion>
    <DownloadDirectory>$(ArtifactsDir)PackageDownload/</DownloadDirectory>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.DotNet.Build.Tasks.Feed" Version="$(MicrosoftDotNetBuildTasksFeedVersion)" />
  </ItemGroup>

    <!--
    Look through the downloaded artifacts to figure out how to ship them. Creates item groups for
    other types of publishing to use.

    DownloadDirectory is expected to have some directory inside, which then contains a dir for each
    build job name. For example, this nupkg would be found:

      $(DownloadDirectory)IntermediateUnsignedArtifacts\Windows_x64\Shipping\a.nupkg
  -->
  <Target Name="FindDownloadedArtifacts"
          BeforeTargets="GenerateChecksums">
    <ItemGroup>
      <DownloadedArtifactFile Include="$(DownloadDirectory)**" />

      <DownloadedSymbolNupkgFile Include="$(DownloadDirectory)**\*.symbols.nupkg" />
      <DownloadedNupkgFile
        Include="$(DownloadDirectory)**\*.nupkg"
        Exclude="@(DownloadedSymbolNupkgFile)" />

      <!-- Add files that are not affected by filtering. -->
      <UploadToBlobStorageFile
        Include="@(DownloadedArtifactFile)"
        Exclude="@(DownloadedSymbolNupkgFile);@(DownloadedNupkgFile)" />

      <!--
        Filter out the RID-specific (Runtime) nupkgs and RID-agnostic nupkgs. RID-specific packages
        are published from every job. RID-agnostic nupkgs are built with the same ID/version by
        every job, so one specific job's outputs must be picked to sign and publish.

        Publish all packages from every job - update patterns in RidSpecificNupkgFile item-group, if this changes.
      -->
      <RidSpecificNupkgFile
        Include="
          $(DownloadDirectory)**\*.nupkg"
        Exclude="@(DownloadedSymbolNupkgFile)" />

      <RidAgnosticNupkgToPublishFile
        Include="$(DownloadDirectory)*\$(PublishRidAgnosticPackagesFromJobName)\**\*.nupkg"
        Exclude="@(RidSpecificNupkgFile);@(DownloadedSymbolNupkgFile)" />

      <NupkgToPublishFile Include="@(RidSpecificNupkgFile);@(RidAgnosticNupkgToPublishFile)" />

      <UploadToBlobStorageFile Include="@(NupkgToPublishFile)" />

      <!--
        Assuming all symbol packages ship and can be found by turning .nupkg => .symbols.nupkg, find
        them. Don't check for missing symbol packages here: some nupkgs don't have them for valid
        reasons, such as the VS insertion packages that transport MSIs. Symbol package validation
        will check for symbol completeness with file-by-file granularity rather than looking for
        missing symbols.nupkg files: https://github.com/dotnet/arcade/issues/2499.
      -->
      <PotentialSymbolNupkgToPublishFile
        Include="@(NupkgToPublishFile->Replace('\NonShipping\', '\Shipping\')->Replace('.nupkg', '.symbols.nupkg'))" />

      <SymbolNupkgToPublishFile
        Include="@(PotentialSymbolNupkgToPublishFile)"
        Condition="Exists('%(Identity)')" />

      <GenerateChecksumItems Include="@(UploadToBlobStorageFile)"
                             DestinationPath="%(FullPath).sha512" />

      <UploadToBlobStorageFile Include="@(SymbolNupkgToPublishFile)" />
    </ItemGroup>
  </Target>

  <Target Name="SignPackages"
          Condition="'$(SkipSigning)' != 'true' and '$(SignType)' != 'public'">
    <Message Importance="High" Text="Signing final packages" />
    <MSBuild
      Projects="$(InstallerProjectRoot)signing\SignFinalPackages.proj"
      Targets="Build"
      Properties="DownloadDirectory=$(DownloadDirectory)" />
  </Target>

  <Target Name="PreparePublishToAzureBlobFeed"
          AfterTargets="Build"
          DependsOnTargets="GetProductVersions;FindDownloadedArtifacts;SignPackages;GenerateChecksums">
    <PropertyGroup>
      <PreparedFileUploadDir>$(ArtifactsObjDir)PreparedFileUpload\</PreparedFileUploadDir>
    </PropertyGroup>

    <ItemGroup>
      <AllFilesToBlobStorage Include="@(UploadToBlobStorageFile);@(UploadToBlobStorageFile)" />
    </ItemGroup>

    <Copy SourceFiles="@(AllFilesToBlobStorage)" DestinationFolder="$(PreparedFileUploadDir)">
      <Output TaskParameter="CopiedFiles" ItemName="CopiedUploadToBlobStorageFile" />
    </Copy>

    <Message Importance="High" Text="Uploading PreparedArtifacts to pipeline" />
    <Message
      Text="##vso[artifact.upload containerfolder=PreparedArtifacts;artifactname=PreparedArtifacts]%(CopiedUploadToBlobStorageFile.Identity)"
      Importance="High" />

    <PropertyGroup>
      <AssetManifestFilename>Manifest.xml</AssetManifestFilename>
      <AssetManifestFile>$(ArtifactsLogDir)AssetManifest/$(AssetManifestFilename)</AssetManifestFile>

      <!-- Create temp dir to store generated asset manifest, per Arcade guidance. -->
      <TempWorkingDir>$(ArtifactsObjDir)TempWorkingDir\$([System.Guid]::NewGuid())\</TempWorkingDir>
    </PropertyGroup>

    <ItemGroup>
      <!-- Split nupkgs into shipping/nonshipping for BAR categorization. -->
      <ShippingNupkgToPublishFile
        Include="@(NupkgToPublishFile)"
        Condition="$([System.String]::new('%(Identity)').Contains('\Shipping\'))" />

      <NonShippingNupkgToPublishFile
        Include="@(NupkgToPublishFile)"
        Exclude="@(ShippingNupkgToPublishFile)" />

      <ItemsToPush Remove="@(ItemsToPush)" />

      <ItemsToPush Include="@(ShippingNupkgToPublishFile)" />
      <ItemsToPush Include="@(NonShippingNupkgToPublishFile)" ManifestArtifactData="NonShipping=true" />
      <ItemsToPush Include="@(SymbolNupkgToPublishFile)" />

      <ItemsToPush
        Include="@(UploadToBlobStorageFile)"
        Exclude="@(NupkgToPublishFile);@(SymbolNupkgToPublishFile)">
        <RelativeBlobPath>$(InstallersRelativePath)%(Filename)%(Extension)</RelativeBlobPath>
        <PublishFlatContainer>true</PublishFlatContainer>
      </ItemsToPush>

      <!-- Must be a different item as otherwise FileName and Extension would refer to the wrong identity. -->
      <GeneratedChecksumFile Include="@(GenerateChecksumItems->Metadata('DestinationPath'))" />
      <ItemsToPush Include="@(GeneratedChecksumFile)">
        <RelativeBlobPath>$(InstallersRelativePath)%(Filename)%(Extension)</RelativeBlobPath>
        <Category>Checksum</Category>
        <PublishFlatContainer>true</PublishFlatContainer>
      </ItemsToPush>
    </ItemGroup>

    <!--
      The new Maestro/BAR build model keeps separate Azure DevOps and GitHub build information.
      The GitHub information will be extracted based on the Azure DevOps repository.
    -->

    <PropertyGroup>
      <CollectionUri>$(SYSTEM_TEAMFOUNDATIONCOLLECTIONURI)</CollectionUri>
      <!-- When we have dev.azure.com/<account>/ -->
      <AzureDevOpsAccount Condition="$(CollectionUri.IndexOf('dev.azure.com')) >= 0">$(CollectionUri.Split('/')[3])</AzureDevOpsAccount>
      <!-- When we have <account>.visualstudio.com -->
      <AzureDevOpsAccount Condition="$(CollectionUri.IndexOf('visualstudio.com')) >= 0">$(CollectionUri.Split('.')[0].Split('/')[2])</AzureDevOpsAccount>
    </PropertyGroup>
    <ItemGroup>
      <ManifestBuildData Include="InitialAssetsLocation=$(SYSTEM_TEAMFOUNDATIONCOLLECTIONURI)$(SYSTEM_TEAMPROJECT)/_apis/build/builds/$(BUILD_BUILDID)/artifacts" />
      <ManifestBuildData Include="AzureDevOpsBuildId=$(BUILD_BUILDID)" />
      <ManifestBuildData Include="AzureDevOpsBuildDefinitionId=$(SYSTEM_DEFINITIONID)" />
      <ManifestBuildData Include="AzureDevOpsAccount=$(AzureDevOpsAccount)" />
      <ManifestBuildData Include="AzureDevOpsProject=$(SYSTEM_TEAMPROJECT)" />
      <ManifestBuildData Include="AzureDevOpsBuildNumber=$(BUILD_BUILDNUMBER)" />
      <ManifestBuildData Include="AzureDevOpsRepository=$(BUILD_REPOSITORY_URI)" />
      <ManifestBuildData Include="AzureDevOpsBranch=$(BUILD_SOURCEBRANCH)" />
    </ItemGroup>

    <!-- Push items to AzDO as build artifacts, generating the asset manifest as a side effect. -->
    <PushToAzureDevOpsArtifacts
      AzureDevOpsCollectionUri="$(SYSTEM_TEAMFOUNDATIONCOLLECTIONURI)"
      AzureDevOpsProject="$(SYSTEM_TEAMPROJECT)"
      AzureDevOpsBuildId="$(BUILD_BUILDID)"
      ItemsToSign="@(ItemsToSignPostBuild)"
      StrongNameSignInfo="@(StrongNameSignInfo)"
      FileSignInfo="@(FileSignInfo)"
      FileExtensionSignInfo="@(FileExtensionSignInfo)"
      CertificatesSignInfo="@(CertificatesSignInfo)"
      ItemsToPush="@(ItemsToPush)"
      ManifestBuildData="@(ManifestBuildData)"
      ManifestRepoUri="$(BUILD_REPOSITORY_NAME)"
      ManifestBranch="$(BUILD_SOURCEBRANCH)"
      ManifestBuildId="$(BUILD_BUILDNUMBER)"
      ManifestCommit="$(BUILD_SOURCEVERSION)"
      IsStableBuild="$(IsStableBuild)"
      AssetManifestPath="$(AssetManifestFile)" />

    <!-- Copy the generated manifest to the build's artifacts -->
    <Copy SourceFiles="$(AssetManifestFile)" DestinationFolder="$(TempWorkingDir)" />
  </Target>

</Project>
